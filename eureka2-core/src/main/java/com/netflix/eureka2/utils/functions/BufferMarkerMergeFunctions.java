package com.netflix.eureka2.utils.functions;

import java.util.HashMap;
import java.util.Map;

import com.netflix.eureka2.model.interest.Interest;
import com.netflix.eureka2.model.Source;
import com.netflix.eureka2.model.Sourced;
import com.netflix.eureka2.model.notification.ChangeNotification;
import com.netflix.eureka2.model.notification.StreamStateNotification;
import org.slf4j.Logger;
import rx.functions.Func1;

/**
 * A class that provide functions to handle merging of stream state notifications for two cases:
 * - either handle merging of notifications between different sources, or
 * - handle merging of notifications with different interests
 *
 * @author David Liu
 */
public class BufferMarkerMergeFunctions {
    private final Logger logger;

    public BufferMarkerMergeFunctions(Logger loggerToUse) {
        this.logger = loggerToUse;
    }

    /**
     * A function that can be used to merge buffer markers generated by different sources to produce a final, aggregated
     * buffer marker for the stream as a whole. Note that any individual interests from the stream state notifications
     * of the individual sources are overridden with the finalInterest provided.
     *
     * If a BufferEnd was seen when the internal map does not contain any bufferStart, then we emit the bufferEnd eagerly.
     *
     * StreamStateNotifications without a source is considered to be part of the identity source.
     *
     * Note that usage of this func MUST always be followed by a filter(null)
     *
     * @param finalInterest the merged interest to return
     * @param sourceToStr a func1 that converts a given source to an appropriate unique string key
     * @param <T> the data type for the notifications
     * @return a merged streamStateNotification that merges streamStateNotifications between multiple sources
     */
    public <T> Func1<ChangeNotification<T>, ChangeNotification<T>> mergeDiffSources(final Interest<T> finalInterest, final Func1<Source, String> sourceToStr) {
        final ChangeNotification<T> bufferStart = StreamStateNotification.bufferStartNotification(finalInterest);
        final ChangeNotification<T> bufferEnd = StreamStateNotification.bufferEndNotification(finalInterest);

        final String identitySourceKey = "MS";
        final Map<String, StreamStateNotification<T>> bufferStartMap = new HashMap<>();

        return new Func1<ChangeNotification<T>, ChangeNotification<T>>() {
            @Override
            public ChangeNotification<T> call(ChangeNotification<T> changeNotification) {
                if (!changeNotification.isStreamStateNotification()) {
                    return changeNotification;
                }

                StreamStateNotification<T> notification = (StreamStateNotification) changeNotification;
                String sourceKey;
                if (notification instanceof Sourced) {
                    sourceKey = sourceToStr.call(((Sourced) notification).getSource());
                } else {
                    sourceKey = identitySourceKey;
                    logger.warn("notification does not contain a source: {}", notification);
                }

                ChangeNotification<T> toReturn = null;
                switch (notification.getBufferState()) {
                    case BufferStart:
                        if (bufferStartMap.isEmpty()) {  // the first add, so emit an aggregated bufferStart
                            toReturn = bufferStart;
                        }
                        StreamStateNotification<T> prevStart = bufferStartMap.put(sourceKey, notification);
                        if (prevStart != null) {
                            logger.warn("saw a bufferStart that overwrote an earlier bufferStart for source: {}", sourceKey);
                        }
                        break;
                    case BufferEnd:
                        StreamStateNotification<T> correspondingStart = bufferStartMap.remove(sourceKey);  // remove the bufferStart
                        if (correspondingStart == null) {
                            logger.warn("saw a bufferEnd without a matching bufferStart for source: {}", sourceKey);
                        }
                        if (bufferStartMap.isEmpty()) {
                            toReturn = bufferEnd;
                        }
                        break;
                    default:
                        // no-op, cannot get here
                }

                return toReturn;
            }
        };
    }

    /**
     * A function that can be used to merge buffer markers generated by datastreams from different atomic interest subscriptions
     * to produce a final, aggregated buffer marker for the stream as a whole.
     *
     * Note that if a buffermarker for a multiple interest is passed through this function, it is discarded
     *
     * Note that usage of this func MUST always be followed by a filter(null)
     *
     * @param finalInterest the final merged interest
     * @param <T> the data type for the notifications
     * @return a merged streamStateNotification that merges streamStateNotifications between multiple atomic interest streams
     */
    public <T> Func1<ChangeNotification<T>, ChangeNotification<T>> mergeDiffAtomicInterests(final Interest<T> finalInterest) {
        final StreamStateNotification<T> bufferStart = StreamStateNotification.bufferStartNotification(finalInterest);
        final StreamStateNotification<T> bufferEnd = StreamStateNotification.bufferEndNotification(finalInterest);

        final Map<Interest<T>, StreamStateNotification<T>> bufferStartMap = new HashMap<>();

        return new Func1<ChangeNotification<T>, ChangeNotification<T>>() {
            @Override
            public ChangeNotification<T> call(ChangeNotification<T> changeNotification) {
                if (changeNotification.isStreamStateNotification()) {
                    StreamStateNotification<T> notification = (StreamStateNotification) changeNotification;
                    Interest<T> interest = notification.getInterest();
                    if (!interest.isAtomicInterest()) {
                        logger.warn("Interest is not atomic {}", interest);
                        return null;
                    }
                    ChangeNotification<T> toReturn = null;
                    switch (notification.getBufferState()) {
                        case BufferStart:
                            if (bufferStartMap.isEmpty()) {  // the first add, so emit an aggregated bufferStart
                                toReturn = bufferStart;
                            }
                            StreamStateNotification<T> prevStart = bufferStartMap.put(interest, notification);
                            if (prevStart != null) {
                                logger.warn("saw a bufferStart that overwrote an earlier bufferStart for interest {}", interest);
                            }
                            break;
                        case BufferEnd:
                            StreamStateNotification<T> correspondingStart = bufferStartMap.remove(interest);  // remove the bufferStart
                            if (correspondingStart == null) {
                                logger.warn("saw a bufferEnd without a matching bufferStart for interest {}", interest);
                            }
                            if (bufferStartMap.isEmpty()) {
                                toReturn = bufferEnd;
                            }
                            break;
                        default:
                            // no-op, cannot get here
                    }

                    return toReturn;
                } else {
                    return changeNotification;
                }
            }
        };
    }
}
